// Generated by CoffeeScript 1.10.0
(function() {
  var NESTED_COFFEESCRIPT_PATTERN, analyze, churn, clamp, complexity, count, execSync, files, fs, glob, gpa, isLiterate, letterGrade, longFilePenalty, report, rules, tokens, tokensForFile, version;

  version = require("../package.json").version;

  execSync = require("child_process").execSync;

  tokens = require("coffee-script").tokens;

  rules = require("./rules");

  fs = require("fs");

  glob = require("glob");

  NESTED_COFFEESCRIPT_PATTERN = "/**/*\.+(coffee|coffee\.md|litcoffee)";

  clamp = function(number, min, max) {
    return Math.max(Math.min(max, number), min);
  };

  isLiterate = function(path) {
    return /\.litcoffee|\.coffee\.md/i.test(path);
  };

  tokensForFile = function(path) {
    var file;
    file = fs.readFileSync(path, "utf8");
    return tokens(file, {
      literate: isLiterate(path)
    });
  };

  churn = function(filePath) {
    var command, output;
    command = "git whatchanged " + filePath + " | grep 'commit' | wc -l";
    output = execSync(command);
    return parseInt(output, 10);
  };

  count = function(filePath) {
    return tokensForFile(filePath).length;
  };

  complexity = function(filePath) {
    return tokensForFile(filePath).reduce(function(sum, token) {
      var type;
      type = token[0];
      return sum += rules[type] || 0;
    }, 0);
  };

  longFilePenalty = function(tokens) {
    if ((0 <= tokens && tokens <= 200)) {
      return 0;
    } else if ((200 < tokens && tokens <= 300)) {
      return 0.25;
    } else if ((300 < tokens && tokens <= 500)) {
      return 0.5;
    } else if (tokens > 500) {
      return 1;
    }
  };

  gpa = function(filePath) {
    var base, penalized, tokenCount;
    tokenCount = count(filePath);
    if (tokenCount === 0) {
      return 0;
    }
    base = tokenCount / complexity(filePath);
    penalized = (base * 4) - longFilePenalty(tokenCount);
    return clamp(penalized, 0, 4);
  };

  letterGrade = function(numericGrade) {
    if ((0 <= numericGrade && numericGrade <= 0.8)) {
      return "F";
    } else if ((0.8 < numericGrade && numericGrade <= 1.6)) {
      return "D";
    } else if ((1.6 < numericGrade && numericGrade <= 2.4)) {
      return "C";
    } else if ((2.4 < numericGrade && numericGrade <= 3.2)) {
      return "B";
    } else if ((3.2 < numericGrade && numericGrade <= 4)) {
      return "A";
    }
  };

  files = function(paths) {
    return paths.reduce(function(list, path) {
      var pattern, stats;
      stats = fs.lstatSync(path);
      if (stats.isFile()) {
        list.push(path);
      } else if (stats.isDirectory()) {
        pattern = path + NESTED_COFFEESCRIPT_PATTERN;
        list = list.concat(glob.sync(pattern));
      }
      return list;
    }, []);
  };

  analyze = function(file) {
    var numericGrade;
    numericGrade = gpa(file);
    return {
      gpa: numericGrade,
      letterGrade: letterGrade(numericGrade),
      churn: churn(file),
      complexity: complexity(file),
      tokenCount: count(file)
    };
  };

  report = function(filePaths, opts) {
    var scores;
    if (opts == null) {
      opts = {};
    }
    scores = files(filePaths).reduce(function(hash, file) {
      hash[file] = analyze(file);
      return hash;
    }, {});
    return JSON.stringify(scores, null, opts.indentSpace);
  };

  exports.clog = {
    report: report,
    VERSION: version
  };

}).call(this);
